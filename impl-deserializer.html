
<!DOCTYPE HTML>
<html lang="en" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Implementing a Deserializer Â· Serde</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-codeblock-rust/block.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-checklist/checklist.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="lifetimes.html" />
    
    
    <link rel="prev" href="impl-serializer.html" />
    

    </head>
    <body>
        
<div class="book with-summary font-size-2">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="help.html">
            
                <a href="help.html">
            
                    
                    Help
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="data-model.html">
            
                <a href="data-model.html">
            
                    
                    Serde data model
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="derive.html">
            
                <a href="derive.html">
            
                    
                    Using derive
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="attributes.html">
            
                <a href="attributes.html">
            
                    
                    Attributes
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="container-attrs.html">
            
                <a href="container-attrs.html">
            
                    
                    Container attributes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="variant-attrs.html">
            
                <a href="variant-attrs.html">
            
                    
                    Variant attributes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="field-attrs.html">
            
                <a href="field-attrs.html">
            
                    
                    Field attributes
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="custom-serialization.html">
            
                <a href="custom-serialization.html">
            
                    
                    Custom serialization
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="impl-serialize.html">
            
                <a href="impl-serialize.html">
            
                    
                    Implementing Serialize
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="impl-deserialize.html">
            
                <a href="impl-deserialize.html">
            
                    
                    Implementing Deserialize
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="unit-testing.html">
            
                <a href="unit-testing.html">
            
                    
                    Unit testing
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="data-format.html">
            
                <a href="data-format.html">
            
                    
                    Writing a data format
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="conventions.html">
            
                <a href="conventions.html">
            
                    
                    Conventions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="error-handling.html">
            
                <a href="error-handling.html">
            
                    
                    Error handling
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="impl-serializer.html">
            
                <a href="impl-serializer.html">
            
                    
                    Implementing a Serializer
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.7.4" data-path="impl-deserializer.html">
            
                <a href="impl-deserializer.html">
            
                    
                    Implementing a Deserializer
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="lifetimes.html">
            
                <a href="lifetimes.html">
            
                    
                    Deserializer lifetimes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="examples.html">
            
                <a href="examples.html">
            
                    
                    Examples
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="json.html">
            
                <a href="json.html">
            
                    
                    Structs and enums in JSON
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="enum-representations.html">
            
                <a href="enum-representations.html">
            
                    
                    Enum representations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="attr-default.html">
            
                <a href="attr-default.html">
            
                    
                    Default value for a field
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="attr-flatten.html">
            
                <a href="attr-flatten.html">
            
                    
                    Struct flattening
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="attr-bound.html">
            
                <a href="attr-bound.html">
            
                    
                    Handwritten generic type bounds
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="deserialize-map.html">
            
                <a href="deserialize-map.html">
            
                    
                    Deserialize for custom map type
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="stream-array.html">
            
                <a href="stream-array.html">
            
                    
                    Array of values without buffering
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.8" data-path="enum-number.html">
            
                <a href="enum-number.html">
            
                    
                    Serialize enum as number
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.9" data-path="attr-rename.html">
            
                <a href="attr-rename.html">
            
                    
                    Serialize fields as camelCase
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.10" data-path="attr-skip-serializing.html">
            
                <a href="attr-skip-serializing.html">
            
                    
                    Skip serializing field
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.11" data-path="remote-derive.html">
            
                <a href="remote-derive.html">
            
                    
                    Derive for remote crate
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.12" data-path="deserialize-struct.html">
            
                <a href="deserialize-struct.html">
            
                    
                    Manually deserialize struct
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.13" data-path="ignored-any.html">
            
                <a href="ignored-any.html">
            
                    
                    Discarding data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.14" data-path="transcode.html">
            
                <a href="transcode.html">
            
                    
                    Transcode into another format
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.15" data-path="string-or-struct.html">
            
                <a href="string-or-struct.html">
            
                    
                    Either string or struct
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.16" data-path="convert-error.html">
            
                <a href="convert-error.html">
            
                    
                    Convert error types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.17" data-path="custom-date-format.html">
            
                <a href="custom-date-format.html">
            
                    
                    Custom date format
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="no-std.html">
            
                <a href="no-std.html">
            
                    
                    No-std support
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="feature-flags.html">
            
                <a href="feature-flags.html">
            
                    
                    Feature flags
            
                </a>
            

            
        </li>
    

    
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Implementing a Deserializer</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="implementing-a-deserializer"><a name="implementing-a-deserializer" class="plugin-anchor" href="#implementing-a-deserializer"><i class="fa fa-link" aria-hidden="true"></i></a>Implementing a Deserializer</h1>
<p>This page gives a basic but functional implementation of a JSON deserializer
using Serde.</p>
<p>As with the serializer, the <a href="https://docs.serde.rs/serde/de/trait.Deserializer.html" target="_blank"><code>Deserializer</code></a> trait has a lot of methods but none
of them are complicated in this implementation. The deserializer is responsible
for mapping the input data into <a href="data-model.html">Serde&apos;s data model</a> by invoking exactly one of
the methods on the <a href="https://docs.serde.rs/serde/de/trait.Visitor.html" target="_blank"><code>Visitor</code></a> that it receives.</p>
<p>The <code>Deserializer</code> methods are called by a <code>Deserialize</code> impl as a hint to
indicate what Serde data model type the <code>Deserialize</code> type expects to see in the
input. For self-describing formats like JSON, it is fine for the <code>Deserializer</code>
to ignore this hint and just call whichever <code>Visitor</code> method corresponds to the
content of the input data. Other formats, especially compact binary formats like
Bincode, rely on the hint to determine how the input data is to be interpreted.</p>
<p>Self-describing formats can save a lot of code by using the
<a href="https://docs.serde.rs/serde/macro.forward_to_deserialize_any.html" target="_blank"><code>forward_to_deserialize_any!</code></a> macro to ignore hints and forward some or all of
the methods of the <code>Deserializer</code> trait to the <code>deserialize_any</code> method.</p>
<p>The code below implements every method explicitly for documentation purposes but
there is no advantage to that.</p>
<p><a href="lifetimes.html">Deserializer lifetimes</a> have their own dedicated page.</p>
<div><p class="code-filename">src/de.rs</p></div>
<pre><code class="lang-rust"><span class="hljs-keyword">use</span> std::ops::{AddAssign, MulAssign, Neg};

<span class="hljs-keyword">use</span> serde::Deserialize;
<span class="hljs-keyword">use</span> serde::de::{
    <span class="hljs-keyword">self</span>, DeserializeSeed, EnumAccess, IntoDeserializer, MapAccess, SeqAccess,
    VariantAccess, Visitor,
};

<span class="hljs-keyword">use</span> error::{Error, <span class="hljs-built_in">Result</span>};

<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Deserializer</span></span>&lt;<span class="hljs-symbol">&apos;de</span>&gt; {
    <span class="hljs-comment">// This string starts with the input data and characters are truncated off</span>
    <span class="hljs-comment">// the beginning as data is parsed.</span>
    input: &amp;<span class="hljs-symbol">&apos;de</span> <span class="hljs-keyword">str</span>,
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&apos;de</span>&gt; Deserializer&lt;<span class="hljs-symbol">&apos;de</span>&gt; {
    <span class="hljs-comment">// By convention, `Deserializer` constructors are named like `from_xyz`.</span>
    <span class="hljs-comment">// That way basic use cases are satisfied by something like</span>
    <span class="hljs-comment">// `serde_json::from_str(...)` while advanced use cases that require a</span>
    <span class="hljs-comment">// deserializer can make one with `serde_json::Deserializer::from_str(...)`.</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_str</span></span>(input: &amp;<span class="hljs-symbol">&apos;de</span> <span class="hljs-keyword">str</span>) -&gt; <span class="hljs-keyword">Self</span> {
        Deserializer { input }
    }
}

<span class="hljs-comment">// By convention, the public API of a Serde deserializer is one or more</span>
<span class="hljs-comment">// `from_xyz` methods such as `from_str`, `from_bytes`, or `from_reader`</span>
<span class="hljs-comment">// depending on what Rust types the deserializer is able to consume as input.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// This basic deserializer supports only `from_str`.</span>
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_str</span></span>&lt;<span class="hljs-symbol">&apos;a</span>, T&gt;(s: &amp;<span class="hljs-symbol">&apos;a</span> <span class="hljs-keyword">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;T&gt;
<span class="hljs-keyword">where</span>
    T: Deserialize&lt;<span class="hljs-symbol">&apos;a</span>&gt;,
{
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> deserializer = Deserializer::from_str(s);
    <span class="hljs-keyword">let</span> t = T::deserialize(&amp;<span class="hljs-keyword">mut</span> deserializer)?;
    <span class="hljs-keyword">if</span> deserializer.input.is_empty() {
        <span class="hljs-literal">Ok</span>(t)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-literal">Err</span>(Error::TrailingCharacters)
    }
}

<span class="hljs-comment">// SERDE IS NOT A PARSING LIBRARY. This impl block defines a few basic parsing</span>
<span class="hljs-comment">// functions from scratch. More complicated formats may wish to use a dedicated</span>
<span class="hljs-comment">// parsing library to help implement their Serde deserializer.</span>
<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&apos;de</span>&gt; Deserializer&lt;<span class="hljs-symbol">&apos;de</span>&gt; {
    <span class="hljs-comment">// Look at the first character in the input without consuming it.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">peek_char</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">char</span>&gt; {
        <span class="hljs-keyword">self</span>.input.chars().next().ok_or(Error::Eof)
    }

    <span class="hljs-comment">// Consume the first character in the input.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_char</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">char</span>&gt; {
        <span class="hljs-keyword">let</span> ch = <span class="hljs-keyword">self</span>.peek_char()?;
        <span class="hljs-keyword">self</span>.input = &amp;<span class="hljs-keyword">self</span>.input[ch.len_utf8()..];
        <span class="hljs-literal">Ok</span>(ch)
    }

    <span class="hljs-comment">// Parse the JSON identifier `true` or `false`.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse_bool</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">bool</span>&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.input.starts_with(<span class="hljs-string">&quot;true&quot;</span>) {
            <span class="hljs-keyword">self</span>.input = &amp;<span class="hljs-keyword">self</span>.input[<span class="hljs-string">&quot;true&quot;</span>.len()..];
            <span class="hljs-literal">Ok</span>(<span class="hljs-literal">true</span>)
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.input.starts_with(<span class="hljs-string">&quot;false&quot;</span>) {
            <span class="hljs-keyword">self</span>.input = &amp;<span class="hljs-keyword">self</span>.input[<span class="hljs-string">&quot;false&quot;</span>.len()..];
            <span class="hljs-literal">Ok</span>(<span class="hljs-literal">false</span>)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">Err</span>(Error::ExpectedBoolean)
        }
    }

    <span class="hljs-comment">// Parse a group of decimal digits as an unsigned integer of type T.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// This implementation is a bit too lenient, for example `001` is not</span>
    <span class="hljs-comment">// allowed in JSON. Also the various arithmetic operations can overflow and</span>
    <span class="hljs-comment">// panic or return bogus data. But it is good enough for example code!</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse_unsigned</span></span>&lt;T&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;T&gt;
    <span class="hljs-keyword">where</span>
        T: AddAssign&lt;T&gt; + MulAssign&lt;T&gt; + <span class="hljs-built_in">From</span>&lt;<span class="hljs-keyword">u8</span>&gt;,
    {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">int</span> = <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.next_char()? {
            ch @ <span class="hljs-string">&apos;0&apos;</span>..=<span class="hljs-string">&apos;9&apos;</span> =&gt; T::from(ch <span class="hljs-keyword">as</span> <span class="hljs-keyword">u8</span> - <span class="hljs-string">b&apos;0&apos;</span>),
            _ =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(Error::ExpectedInteger);
            }
        };
        <span class="hljs-keyword">loop</span> {
            <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.input.chars().next() {
                <span class="hljs-literal">Some</span>(ch @ <span class="hljs-string">&apos;0&apos;</span>..=<span class="hljs-string">&apos;9&apos;</span>) =&gt; {
                    <span class="hljs-keyword">self</span>.input = &amp;<span class="hljs-keyword">self</span>.input[<span class="hljs-number">1</span>..];
                    <span class="hljs-keyword">int</span> *= T::from(<span class="hljs-number">10</span>);
                    <span class="hljs-keyword">int</span> += T::from(ch <span class="hljs-keyword">as</span> <span class="hljs-keyword">u8</span> - <span class="hljs-string">b&apos;0&apos;</span>);
                }
                _ =&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(<span class="hljs-keyword">int</span>);
                }
            }
        }
    }

    <span class="hljs-comment">// Parse a possible minus sign followed by a group of decimal digits as a</span>
    <span class="hljs-comment">// signed integer of type T.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse_signed</span></span>&lt;T&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;T&gt;
    <span class="hljs-keyword">where</span>
        T: Neg&lt;Output = T&gt; + AddAssign&lt;T&gt; + MulAssign&lt;T&gt; + <span class="hljs-built_in">From</span>&lt;<span class="hljs-keyword">i8</span>&gt;,
    {
        <span class="hljs-comment">// Optional minus sign, delegate to `parse_unsigned`, negate if negative.</span>
        <span class="hljs-built_in">unimplemented!</span>()
    }

    <span class="hljs-comment">// Parse a string until the next &apos;&quot;&apos; character.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Makes no attempt to handle escape sequences. What did you expect? This is</span>
    <span class="hljs-comment">// example code!</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse_string</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;&amp;<span class="hljs-symbol">&apos;de</span> <span class="hljs-keyword">str</span>&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.next_char()? != <span class="hljs-string">&apos;&quot;&apos;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(Error::ExpectedString);
        }
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.input.find(<span class="hljs-string">&apos;&quot;&apos;</span>) {
            <span class="hljs-literal">Some</span>(len) =&gt; {
                <span class="hljs-keyword">let</span> s = &amp;<span class="hljs-keyword">self</span>.input[..len];
                <span class="hljs-keyword">self</span>.input = &amp;<span class="hljs-keyword">self</span>.input[len + <span class="hljs-number">1</span>..];
                <span class="hljs-literal">Ok</span>(s)
            }
            <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">Err</span>(Error::Eof),
        }
    }
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&apos;de</span>, <span class="hljs-symbol">&apos;a</span>&gt; de::Deserializer&lt;<span class="hljs-symbol">&apos;de</span>&gt; <span class="hljs-keyword">for</span> &amp;<span class="hljs-symbol">&apos;a</span> <span class="hljs-keyword">mut</span> Deserializer&lt;<span class="hljs-symbol">&apos;de</span>&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = Error;

    <span class="hljs-comment">// Look at the input data to decide what Serde data model type to</span>
    <span class="hljs-comment">// deserialize as. Not all data formats are able to support this operation.</span>
    <span class="hljs-comment">// Formats that support `deserialize_any` are known as self-describing.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_any</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.peek_char()? {
            <span class="hljs-string">&apos;n&apos;</span> =&gt; <span class="hljs-keyword">self</span>.deserialize_unit(visitor),
            <span class="hljs-string">&apos;t&apos;</span> | <span class="hljs-string">&apos;f&apos;</span> =&gt; <span class="hljs-keyword">self</span>.deserialize_bool(visitor),
            <span class="hljs-string">&apos;&quot;&apos;</span> =&gt; <span class="hljs-keyword">self</span>.deserialize_str(visitor),
            <span class="hljs-string">&apos;0&apos;</span>..=<span class="hljs-string">&apos;9&apos;</span> =&gt; <span class="hljs-keyword">self</span>.deserialize_u64(visitor),
            <span class="hljs-string">&apos;-&apos;</span> =&gt; <span class="hljs-keyword">self</span>.deserialize_i64(visitor),
            <span class="hljs-string">&apos;[&apos;</span> =&gt; <span class="hljs-keyword">self</span>.deserialize_seq(visitor),
            <span class="hljs-string">&apos;{&apos;</span> =&gt; <span class="hljs-keyword">self</span>.deserialize_map(visitor),
            _ =&gt; <span class="hljs-literal">Err</span>(Error::Syntax),
        }
    }

    <span class="hljs-comment">// Uses the `parse_bool` parsing function defined above to read the JSON</span>
    <span class="hljs-comment">// identifier `true` or `false` from the input.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Parsing refers to looking at the input and deciding that it contains the</span>
    <span class="hljs-comment">// JSON value `true` or `false`.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Deserialization refers to mapping that JSON value into Serde&apos;s data</span>
    <span class="hljs-comment">// model by invoking one of the `Visitor` methods. In the case of JSON and</span>
    <span class="hljs-comment">// bool that mapping is straightforward so the distinction may seem silly,</span>
    <span class="hljs-comment">// but in other cases Deserializers sometimes perform non-obvious mappings.</span>
    <span class="hljs-comment">// For example the TOML format has a Datetime type and Serde&apos;s data model</span>
    <span class="hljs-comment">// does not. In the `toml` crate, a Datetime in the input is deserialized by</span>
    <span class="hljs-comment">// mapping it to a Serde data model &quot;struct&quot; type with a special name and a</span>
    <span class="hljs-comment">// single field containing the Datetime represented as a string.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_bool</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        visitor.visit_bool(<span class="hljs-keyword">self</span>.parse_bool()?)
    }

    <span class="hljs-comment">// The `parse_signed` function is generic over the integer type `T` so here</span>
    <span class="hljs-comment">// it is invoked with `T=i8`. The next 8 methods are similar.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_i8</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        visitor.visit_i8(<span class="hljs-keyword">self</span>.parse_signed()?)
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_i16</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        visitor.visit_i16(<span class="hljs-keyword">self</span>.parse_signed()?)
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_i32</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        visitor.visit_i32(<span class="hljs-keyword">self</span>.parse_signed()?)
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_i64</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        visitor.visit_i64(<span class="hljs-keyword">self</span>.parse_signed()?)
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_u8</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        visitor.visit_u8(<span class="hljs-keyword">self</span>.parse_unsigned()?)
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_u16</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        visitor.visit_u16(<span class="hljs-keyword">self</span>.parse_unsigned()?)
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_u32</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        visitor.visit_u32(<span class="hljs-keyword">self</span>.parse_unsigned()?)
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_u64</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        visitor.visit_u64(<span class="hljs-keyword">self</span>.parse_unsigned()?)
    }

    <span class="hljs-comment">// Float parsing is stupidly hard.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_f32</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, _visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-built_in">unimplemented!</span>()
    }

    <span class="hljs-comment">// Float parsing is stupidly hard.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_f64</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, _visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-built_in">unimplemented!</span>()
    }

    <span class="hljs-comment">// The `Serializer` implementation on the previous page serialized chars as</span>
    <span class="hljs-comment">// single-character strings so handle that representation here.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_char</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, _visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-comment">// Parse a string, check that it is one character, call `visit_char`.</span>
        <span class="hljs-built_in">unimplemented!</span>()
    }

    <span class="hljs-comment">// Refer to the &quot;Understanding deserializer lifetimes&quot; page for information</span>
    <span class="hljs-comment">// about the three deserialization flavors of strings in Serde.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_str</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        visitor.visit_borrowed_str(<span class="hljs-keyword">self</span>.parse_string()?)
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_string</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-keyword">self</span>.deserialize_str(visitor)
    }

    <span class="hljs-comment">// The `Serializer` implementation on the previous page serialized byte</span>
    <span class="hljs-comment">// arrays as JSON arrays of bytes. Handle that representation here.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_bytes</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, _visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-built_in">unimplemented!</span>()
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_byte_buf</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, _visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-built_in">unimplemented!</span>()
    }

    <span class="hljs-comment">// An absent optional is represented as the JSON `null` and a present</span>
    <span class="hljs-comment">// optional is represented as just the contained value.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// As commented in `Serializer` implementation, this is a lossy</span>
    <span class="hljs-comment">// representation. For example the values `Some(())` and `None` both</span>
    <span class="hljs-comment">// serialize as just `null`. Unfortunately this is typically what people</span>
    <span class="hljs-comment">// expect when working with JSON. Other formats are encouraged to behave</span>
    <span class="hljs-comment">// more intelligently if possible.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_option</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.input.starts_with(<span class="hljs-string">&quot;null&quot;</span>) {
            <span class="hljs-keyword">self</span>.input = &amp;<span class="hljs-keyword">self</span>.input[<span class="hljs-string">&quot;null&quot;</span>.len()..];
            visitor.visit_none()
        } <span class="hljs-keyword">else</span> {
            visitor.visit_some(<span class="hljs-keyword">self</span>)
        }
    }

    <span class="hljs-comment">// In Serde, unit means an anonymous value containing no data.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_unit</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.input.starts_with(<span class="hljs-string">&quot;null&quot;</span>) {
            <span class="hljs-keyword">self</span>.input = &amp;<span class="hljs-keyword">self</span>.input[<span class="hljs-string">&quot;null&quot;</span>.len()..];
            visitor.visit_unit()
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">Err</span>(Error::ExpectedNull)
        }
    }

    <span class="hljs-comment">// Unit struct means a named value containing no data.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_unit_struct</span></span>&lt;V&gt;(
        <span class="hljs-keyword">self</span>,
        _name: &amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-keyword">str</span>,
        visitor: V,
    ) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-keyword">self</span>.deserialize_unit(visitor)
    }

    <span class="hljs-comment">// As is done here, serializers are encouraged to treat newtype structs as</span>
    <span class="hljs-comment">// insignificant wrappers around the data they contain. That means not</span>
    <span class="hljs-comment">// parsing anything other than the contained value.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_newtype_struct</span></span>&lt;V&gt;(
        <span class="hljs-keyword">self</span>,
        _name: &amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-keyword">str</span>,
        visitor: V,
    ) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        visitor.visit_newtype_struct(<span class="hljs-keyword">self</span>)
    }

    <span class="hljs-comment">// Deserialization of compound types like sequences and maps happens by</span>
    <span class="hljs-comment">// passing the visitor an &quot;Access&quot; object that gives it the ability to</span>
    <span class="hljs-comment">// iterate through the data contained in the sequence.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_seq</span></span>&lt;V&gt;(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-comment">// Parse the opening bracket of the sequence.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.next_char()? == <span class="hljs-string">&apos;[&apos;</span> {
            <span class="hljs-comment">// Give the visitor access to each element of the sequence.</span>
            <span class="hljs-keyword">let</span> value = visitor.visit_seq(CommaSeparated::new(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>))?;
            <span class="hljs-comment">// Parse the closing bracket of the sequence.</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.next_char()? == <span class="hljs-string">&apos;]&apos;</span> {
                <span class="hljs-literal">Ok</span>(value)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-literal">Err</span>(Error::ExpectedArrayEnd)
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">Err</span>(Error::ExpectedArray)
        }
    }

    <span class="hljs-comment">// Tuples look just like sequences in JSON. Some formats may be able to</span>
    <span class="hljs-comment">// represent tuples more efficiently.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// As indicated by the length parameter, the `Deserialize` implementation</span>
    <span class="hljs-comment">// for a tuple in the Serde data model is required to know the length of the</span>
    <span class="hljs-comment">// tuple before even looking at the input data.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_tuple</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, _len: usize, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-keyword">self</span>.deserialize_seq(visitor)
    }

    <span class="hljs-comment">// Tuple structs look just like sequences in JSON.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_tuple_struct</span></span>&lt;V&gt;(
        <span class="hljs-keyword">self</span>,
        _name: &amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-keyword">str</span>,
        _len: usize,
        visitor: V,
    ) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-keyword">self</span>.deserialize_seq(visitor)
    }

    <span class="hljs-comment">// Much like `deserialize_seq` but calls the visitors `visit_map` method</span>
    <span class="hljs-comment">// with a `MapAccess` implementation, rather than the visitor&apos;s `visit_seq`</span>
    <span class="hljs-comment">// method with a `SeqAccess` implementation.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_map</span></span>&lt;V&gt;(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-comment">// Parse the opening brace of the map.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.next_char()? == <span class="hljs-string">&apos;{&apos;</span> {
            <span class="hljs-comment">// Give the visitor access to each entry of the map.</span>
            <span class="hljs-keyword">let</span> value = visitor.visit_map(CommaSeparated::new(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>))?;
            <span class="hljs-comment">// Parse the closing brace of the map.</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.next_char()? == <span class="hljs-string">&apos;}&apos;</span> {
                <span class="hljs-literal">Ok</span>(value)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-literal">Err</span>(Error::ExpectedMapEnd)
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">Err</span>(Error::ExpectedMap)
        }
    }

    <span class="hljs-comment">// Structs look just like maps in JSON.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Notice the `fields` parameter - a &quot;struct&quot; in the Serde data model means</span>
    <span class="hljs-comment">// that the `Deserialize` implementation is required to know what the fields</span>
    <span class="hljs-comment">// are before even looking at the input data. Any key-value pairing in which</span>
    <span class="hljs-comment">// the fields cannot be known ahead of time is probably a map.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_struct</span></span>&lt;V&gt;(
        <span class="hljs-keyword">self</span>,
        _name: &amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-keyword">str</span>,
        _fields: &amp;<span class="hljs-symbol">&apos;static</span> [&amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-keyword">str</span>],
        visitor: V,
    ) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-keyword">self</span>.deserialize_map(visitor)
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_enum</span></span>&lt;V&gt;(
        <span class="hljs-keyword">self</span>,
        _name: &amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-keyword">str</span>,
        _variants: &amp;<span class="hljs-symbol">&apos;static</span> [&amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-keyword">str</span>],
        visitor: V,
    ) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.peek_char()? == <span class="hljs-string">&apos;&quot;&apos;</span> {
            <span class="hljs-comment">// Visit a unit variant.</span>
            visitor.visit_enum(<span class="hljs-keyword">self</span>.parse_string()?.into_deserializer())
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.next_char()? == <span class="hljs-string">&apos;{&apos;</span> {
            <span class="hljs-comment">// Visit a newtype variant, tuple variant, or struct variant.</span>
            <span class="hljs-keyword">let</span> value = visitor.visit_enum(Enum::new(<span class="hljs-keyword">self</span>))?;
            <span class="hljs-comment">// Parse the matching close brace.</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.next_char()? == <span class="hljs-string">&apos;}&apos;</span> {
                <span class="hljs-literal">Ok</span>(value)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-literal">Err</span>(Error::ExpectedMapEnd)
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">Err</span>(Error::ExpectedEnum)
        }
    }

    <span class="hljs-comment">// An identifier in Serde is the type that identifies a field of a struct or</span>
    <span class="hljs-comment">// the variant of an enum. In JSON, struct fields and enum variants are</span>
    <span class="hljs-comment">// represented as strings. In other formats they may be represented as</span>
    <span class="hljs-comment">// numeric indices.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_identifier</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-keyword">self</span>.deserialize_str(visitor)
    }

    <span class="hljs-comment">// Like `deserialize_any` but indicates to the `Deserializer` that it makes</span>
    <span class="hljs-comment">// no difference which `Visitor` method is called because the data is</span>
    <span class="hljs-comment">// ignored.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Some deserializers are able to implement this more efficiently than</span>
    <span class="hljs-comment">// `deserialize_any`, for example by rapidly skipping over matched</span>
    <span class="hljs-comment">// delimiters without paying close attention to the data in between.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Some formats are not able to implement this at all. Formats that can</span>
    <span class="hljs-comment">// implement `deserialize_any` and `deserialize_ignored_any` are known as</span>
    <span class="hljs-comment">// self-describing.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_ignored_any</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-keyword">self</span>.deserialize_any(visitor)
    }
}

<span class="hljs-comment">// In order to handle commas correctly when deserializing a JSON array or map,</span>
<span class="hljs-comment">// we need to track whether we are on the first element or past the first</span>
<span class="hljs-comment">// element.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CommaSeparated</span></span>&lt;<span class="hljs-symbol">&apos;a</span>, <span class="hljs-symbol">&apos;de</span>: <span class="hljs-symbol">&apos;a</span>&gt; {
    de: &amp;<span class="hljs-symbol">&apos;a</span> <span class="hljs-keyword">mut</span> Deserializer&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    first: <span class="hljs-keyword">bool</span>,
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&apos;a</span>, <span class="hljs-symbol">&apos;de</span>&gt; CommaSeparated&lt;<span class="hljs-symbol">&apos;a</span>, <span class="hljs-symbol">&apos;de</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(de: &amp;<span class="hljs-symbol">&apos;a</span> <span class="hljs-keyword">mut</span> Deserializer&lt;<span class="hljs-symbol">&apos;de</span>&gt;) -&gt; <span class="hljs-keyword">Self</span> {
        CommaSeparated {
            de,
            first: <span class="hljs-literal">true</span>,
        }
    }
}

<span class="hljs-comment">// `SeqAccess` is provided to the `Visitor` to give it the ability to iterate</span>
<span class="hljs-comment">// through elements of the sequence.</span>
<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&apos;de</span>, <span class="hljs-symbol">&apos;a</span>&gt; SeqAccess&lt;<span class="hljs-symbol">&apos;de</span>&gt; <span class="hljs-keyword">for</span> CommaSeparated&lt;<span class="hljs-symbol">&apos;a</span>, <span class="hljs-symbol">&apos;de</span>&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = Error;

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_element_seed</span></span>&lt;T&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, seed: T) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">Option</span>&lt;T::Value&gt;&gt;
    <span class="hljs-keyword">where</span>
        T: DeserializeSeed&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-comment">// Check if there are no more elements.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.de.peek_char()? == <span class="hljs-string">&apos;]&apos;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(<span class="hljs-literal">None</span>);
        }
        <span class="hljs-comment">// Comma is required before every element except the first.</span>
        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.first &amp;&amp; <span class="hljs-keyword">self</span>.de.next_char()? != <span class="hljs-string">&apos;,&apos;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(Error::ExpectedArrayComma);
        }
        <span class="hljs-keyword">self</span>.first = <span class="hljs-literal">false</span>;
        <span class="hljs-comment">// Deserialize an array element.</span>
        seed.deserialize(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.de).map(<span class="hljs-literal">Some</span>)
    }
}

<span class="hljs-comment">// `MapAccess` is provided to the `Visitor` to give it the ability to iterate</span>
<span class="hljs-comment">// through entries of the map.</span>
<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&apos;de</span>, <span class="hljs-symbol">&apos;a</span>&gt; MapAccess&lt;<span class="hljs-symbol">&apos;de</span>&gt; <span class="hljs-keyword">for</span> CommaSeparated&lt;<span class="hljs-symbol">&apos;a</span>, <span class="hljs-symbol">&apos;de</span>&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = Error;

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_key_seed</span></span>&lt;K&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, seed: K) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">Option</span>&lt;K::Value&gt;&gt;
    <span class="hljs-keyword">where</span>
        K: DeserializeSeed&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-comment">// Check if there are no more entries.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.de.peek_char()? == <span class="hljs-string">&apos;}&apos;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(<span class="hljs-literal">None</span>);
        }
        <span class="hljs-comment">// Comma is required before every entry except the first.</span>
        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.first &amp;&amp; <span class="hljs-keyword">self</span>.de.next_char()? != <span class="hljs-string">&apos;,&apos;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(Error::ExpectedMapComma);
        }
        <span class="hljs-keyword">self</span>.first = <span class="hljs-literal">false</span>;
        <span class="hljs-comment">// Deserialize a map key.</span>
        seed.deserialize(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.de).map(<span class="hljs-literal">Some</span>)
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_value_seed</span></span>&lt;V&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, seed: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: DeserializeSeed&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-comment">// It doesn&apos;t make a difference whether the colon is parsed at the end</span>
        <span class="hljs-comment">// of `next_key_seed` or at the beginning of `next_value_seed`. In this</span>
        <span class="hljs-comment">// case the code is a bit simpler having it here.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.de.next_char()? != <span class="hljs-string">&apos;:&apos;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(Error::ExpectedMapColon);
        }
        <span class="hljs-comment">// Deserialize a map value.</span>
        seed.deserialize(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.de)
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Enum</span></span>&lt;<span class="hljs-symbol">&apos;a</span>, <span class="hljs-symbol">&apos;de</span>: <span class="hljs-symbol">&apos;a</span>&gt; {
    de: &amp;<span class="hljs-symbol">&apos;a</span> <span class="hljs-keyword">mut</span> Deserializer&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&apos;a</span>, <span class="hljs-symbol">&apos;de</span>&gt; Enum&lt;<span class="hljs-symbol">&apos;a</span>, <span class="hljs-symbol">&apos;de</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(de: &amp;<span class="hljs-symbol">&apos;a</span> <span class="hljs-keyword">mut</span> Deserializer&lt;<span class="hljs-symbol">&apos;de</span>&gt;) -&gt; <span class="hljs-keyword">Self</span> {
        Enum { de }
    }
}

<span class="hljs-comment">// `EnumAccess` is provided to the `Visitor` to give it the ability to determine</span>
<span class="hljs-comment">// which variant of the enum is supposed to be deserialized.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Note that all enum deserialization methods in Serde refer exclusively to the</span>
<span class="hljs-comment">// &quot;externally tagged&quot; enum representation.</span>
<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&apos;de</span>, <span class="hljs-symbol">&apos;a</span>&gt; EnumAccess&lt;<span class="hljs-symbol">&apos;de</span>&gt; <span class="hljs-keyword">for</span> Enum&lt;<span class="hljs-symbol">&apos;a</span>, <span class="hljs-symbol">&apos;de</span>&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = Error;
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Variant</span></span> = <span class="hljs-keyword">Self</span>;

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">variant_seed</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, seed: V) -&gt; <span class="hljs-built_in">Result</span>&lt;(V::Value, Self::Variant)&gt;
    <span class="hljs-keyword">where</span>
        V: DeserializeSeed&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        <span class="hljs-comment">// The `deserialize_enum` method parsed a `{` character so we are</span>
        <span class="hljs-comment">// currently inside of a map. The seed will be deserializing itself from</span>
        <span class="hljs-comment">// the key of the map.</span>
        <span class="hljs-keyword">let</span> val = seed.deserialize(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.de)?;
        <span class="hljs-comment">// Parse the colon separating map key from value.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.de.next_char()? == <span class="hljs-string">&apos;:&apos;</span> {
            <span class="hljs-literal">Ok</span>((val, <span class="hljs-keyword">self</span>))
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">Err</span>(Error::ExpectedMapColon)
        }
    }
}

<span class="hljs-comment">// `VariantAccess` is provided to the `Visitor` to give it the ability to see</span>
<span class="hljs-comment">// the content of the single variant that it decided to deserialize.</span>
<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&apos;de</span>, <span class="hljs-symbol">&apos;a</span>&gt; VariantAccess&lt;<span class="hljs-symbol">&apos;de</span>&gt; <span class="hljs-keyword">for</span> Enum&lt;<span class="hljs-symbol">&apos;a</span>, <span class="hljs-symbol">&apos;de</span>&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = Error;

    <span class="hljs-comment">// If the `Visitor` expected this variant to be a unit variant, the input</span>
    <span class="hljs-comment">// should have been the plain string case handled in `deserialize_enum`.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">unit_variant</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; {
        <span class="hljs-literal">Err</span>(Error::ExpectedString)
    }

    <span class="hljs-comment">// Newtype variants are represented in JSON as `{ NAME: VALUE }` so</span>
    <span class="hljs-comment">// deserialize the value here.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">newtype_variant_seed</span></span>&lt;T&gt;(<span class="hljs-keyword">self</span>, seed: T) -&gt; <span class="hljs-built_in">Result</span>&lt;T::Value&gt;
    <span class="hljs-keyword">where</span>
        T: DeserializeSeed&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        seed.deserialize(<span class="hljs-keyword">self</span>.de)
    }

    <span class="hljs-comment">// Tuple variants are represented in JSON as `{ NAME: [DATA...] }` so</span>
    <span class="hljs-comment">// deserialize the sequence of data here.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">tuple_variant</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, _len: usize, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        de::Deserializer::deserialize_seq(<span class="hljs-keyword">self</span>.de, visitor)
    }

    <span class="hljs-comment">// Struct variants are represented in JSON as `{ NAME: { K: V, ... } }` so</span>
    <span class="hljs-comment">// deserialize the inner map here.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">struct_variant</span></span>&lt;V&gt;(
        <span class="hljs-keyword">self</span>,
        _fields: &amp;<span class="hljs-symbol">&apos;static</span> [&amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-keyword">str</span>],
        visitor: V,
    ) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;
    <span class="hljs-keyword">where</span>
        V: Visitor&lt;<span class="hljs-symbol">&apos;de</span>&gt;,
    {
        de::Deserializer::deserialize_map(<span class="hljs-keyword">self</span>.de, visitor)
    }
}

<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span>

<span class="hljs-meta">#[test]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_struct</span></span>() {
    <span class="hljs-meta">#[derive(Deserialize, PartialEq, Debug)]</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span></span> {
        <span class="hljs-keyword">int</span>: <span class="hljs-keyword">u32</span>,
        seq: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt;,
    }

    <span class="hljs-keyword">let</span> j = <span class="hljs-string">r#&quot;{&quot;int&quot;:1,&quot;seq&quot;:[&quot;a&quot;,&quot;b&quot;]}&quot;#</span>;
    <span class="hljs-keyword">let</span> expected = Test {
        <span class="hljs-keyword">int</span>: <span class="hljs-number">1</span>,
        seq: <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;a&quot;</span>.to_owned(), <span class="hljs-string">&quot;b&quot;</span>.to_owned()],
    };
    <span class="hljs-built_in">assert_eq!</span>(expected, from_str(j).unwrap());
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_enum</span></span>() {
    <span class="hljs-meta">#[derive(Deserialize, PartialEq, Debug)]</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">E</span></span> {
        Unit,
        Newtype(<span class="hljs-keyword">u32</span>),
        Tuple(<span class="hljs-keyword">u32</span>, <span class="hljs-keyword">u32</span>),
        Struct { a: <span class="hljs-keyword">u32</span> },
    }

    <span class="hljs-keyword">let</span> j = <span class="hljs-string">r#&quot;&quot;Unit&quot;&quot;#</span>;
    <span class="hljs-keyword">let</span> expected = E::Unit;
    <span class="hljs-built_in">assert_eq!</span>(expected, from_str(j).unwrap());

    <span class="hljs-keyword">let</span> j = <span class="hljs-string">r#&quot;{&quot;Newtype&quot;:1}&quot;#</span>;
    <span class="hljs-keyword">let</span> expected = E::Newtype(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">assert_eq!</span>(expected, from_str(j).unwrap());

    <span class="hljs-keyword">let</span> j = <span class="hljs-string">r#&quot;{&quot;Tuple&quot;:[1,2]}&quot;#</span>;
    <span class="hljs-keyword">let</span> expected = E::Tuple(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
    <span class="hljs-built_in">assert_eq!</span>(expected, from_str(j).unwrap());

    <span class="hljs-keyword">let</span> j = <span class="hljs-string">r#&quot;{&quot;Struct&quot;:{&quot;a&quot;:1}}&quot;#</span>;
    <span class="hljs-keyword">let</span> expected = E::Struct { a: <span class="hljs-number">1</span> };
    <span class="hljs-built_in">assert_eq!</span>(expected, from_str(j).unwrap());
}
</code></pre>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="impl-serializer.html" class="navigation navigation-prev " aria-label="Previous page: Implementing a Serializer">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="lifetimes.html" class="navigation navigation-next " aria-label="Next page: Deserializer lifetimes">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Implementing a Deserializer","level":"1.7.4","depth":2,"next":{"title":"Deserializer lifetimes","level":"1.8","depth":1,"path":"lifetimes.md","ref":"lifetimes.md","articles":[]},"previous":{"title":"Implementing a Serializer","level":"1.7.3","depth":2,"path":"impl-serializer.md","ref":"impl-serializer.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-sharing","sane-sidebar","codeblock-omit","codeblock-rust","edit-link","ga","bulk-redirect","checklist","anchors"],"root":"_src","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"checklist":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"codeblock-rust":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"sane-sidebar":{},"codeblock-omit":{},"bulk-redirect":{"redirectsFile":"redirects.json"},"ga":{"configuration":"auto","token":"UA-82804814-1"},"edit-link":{"label":"Edit","base":"https://github.com/serde-rs/serde-rs.github.io/edit/master/_src"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchors":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Serde","language":"en","gitbook":"*"},"file":{"path":"impl-deserializer.md","mtime":"2020-03-10T05:07:45.268Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-12-21T18:34:17.573Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-sane-sidebar/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-edit-link/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-ga/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

